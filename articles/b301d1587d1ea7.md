---
title: '個人的に考えるVRTで確認すること・しないこと'
emoji: '🔍'
type: 'idea'
topics: ['vrt', 'test', 'frontend']
published: false
---

こんにちは 👋

最近、UI のデグレが気になって「VRT を導入したいな」と思っているんですが、「どのコンポーネントから VRT を始めればいいんだろう？」「全部のパターンをテストしないとダメなのかな？」と迷っていました。

いきなり全部 VRT でカバーしようとすると、文言変更やステータス追加のたびにテスト更新地獄に陥ってしまいそうです。

この記事では、**VRT をこれから始める人が、何をどこまでテストすべきか判断できる基準**を整理したいと思います。小さく始めて、徐々に広げていくための考え方を紹介しますね。

# VRT の本質: 「見た目のロック」であって「仕様テスト」ではない

まず、VRT が何を検出するのかを理解することが大切です。

VRT が検出するのは**ピクセルレベルの差分**です。画面のスクリーンショットを比較して、「見た目が変わっていないか」をチェックします。

これは言い換えると：

```
VRTは「画面が壊れていないか」を見る
  ↓
「画面の機能が正しいか」は別のテスト（React Testing Library などを使った振る舞いテストや E2E）の責務
```

という役割分担になります。

スナップショットテストと混同されがちですが、スナップショットテストは DOM 構造（HTML の文字列）を比較するのに対し、VRT は実際にレンダリングされた画面（ピクセル）を比較します。つまり、VRT は CSS、フォント、画像、ブラウザの描画結果まで含めた「見た目」全体を検証するものです。

:::message
全パターンを網羅的に VRT でカバーしようとすると、テスト更新地獄に陥ります。VRT では構造が異なる代表例だけを確認すれば、意図しないレイアウト崩れは十分に検出できます。
:::

# VRT で何を見るべきかの判断基準

それでは、具体的にどうやって「VRT で見るべきもの」と「VRT で見るべきでないもの」を判断すればよいのでしょうか。

自分は**3 つの基準**で判断するのが良いと考えています。

## 基準 1: 変更頻度

**VRT 向き**: 安定した構造（レイアウト、余白、配置）
**VRT 不向き**: 頻繁に変わるもの（コピー文言、色の微調整、カラム追加）

レイアウトの構造は一度決まったら頻繁には変わりません。一方で、ボタンのラベルやエラーメッセージなどの文言は何度も変更されることがあります。

頻繁に変わるものを VRT で検証すると、変更のたびにスクリーンショットを更新する必要があり、メンテナンスコストが高くなります。

## 基準 2: 変更の種類

**VRT 向き**: 意図しない破壊を検出（CSS 削除ミス、マージン崩れ）
**VRT 不向き**: 意図的な変更（デザインリニューアル、文言修正）

VRT の真の価値は「意図しない変更」を検出することにあります。

例えば、共通の CSS を削除したときに影響範囲が広すぎて気づけなかった、とか、マージンの指定を間違えてレイアウトが崩れた、といった「うっかりミス」を防ぐのが VRT の役割です。

逆に、デザインリニューアルのような「意図的な変更が正しくできているか」を確認する目的で VRT を作るのは不適切です。VRT は変更を検出するツールであって、変更内容の正しさを保証するものではありません。既存の VRT がある場合は、リニューアル期間中は差分を目視確認して baseline 更新するか、VRT をスキップすることになります。

## 基準 3: テスト対象の性質

**VRT 向き**: コンポーネントの構造（折り返し、高さ、配置）
**VRT 不向き**: データ依存（API レスポンス、動的コンテンツ）

コンポーネントの構造的な部分（例: テキストが長すぎて折り返されたときの高さ、アイコンとテキストの配置）は、VRT で検証するのに適しています。

一方、API から取得したデータの内容（例: ユーザー名、日時、ステータスの種類）は、データが変わるたびに VRT が落ちるため不適切です。

## 3 つの基準の使い方

この 3 つの基準を使って判断する際は、**すべての基準で VRT 向きと判断できる場合のみ、VRT の対象にする**のが良いと思います。

以下の表でまとめてみました：

| 判断基準   | VRT 向き             | VRT 不向き               |
| ---------- | -------------------- | ------------------------ |
| 変更頻度   | 安定した構造         | 頻繁に変わる文言やデータ |
| 変更の種類 | 意図しない破壊を検出 | 意図的なデザイン変更     |
| 性質       | コンポーネントの構造 | データ依存の内容         |

# 具体例で理解する

それでは、実際のコンポーネントを例に、3 つの基準を使った判断を見ていきましょう。

## 例 1: ボタンコンポーネント（シンプルな例）

まずはシンプルなボタンコンポーネントから見ていきます。

![見た目が違う3種類のボタンのキャプチャ](https://storage.googleapis.com/zenn-user-upload/e08883c54e49-20251128.png)
_見た目が違う 3 種類のボタン_

:::details 実装コード

```tsx:Button.tsx
type ButtonProps = {
  variant: "primary" | "secondary" | "danger";
  children: ReactNode;
  icon?: ReactNode;
};

const Button = ({ variant, children, icon }: ButtonProps) => {
  const baseStyle =
    "px-4 py-2 rounded font-medium flex items-center gap-2 hover:cursor-pointer";

  const variantStyles = {
    primary: "bg-blue-600 text-white hover:bg-blue-700",
    secondary: "bg-gray-200 text-gray-900 hover:bg-gray-300",
    danger: "bg-red-600 text-white hover:bg-red-700",
  };

  return (
    <button type="button" className={`${baseStyle} ${variantStyles[variant]}`}>
      {icon && <span className="w-5 h-5 inline-flex items-center">{icon}</span>}
      {children}
    </button>
  );
};
```

:::

このボタンコンポーネントには、`primary`/`secondary`/`danger`の 3 つの variant があります。また、アイコン付き/なしのパターンもあります。

### 3 つの基準で判断してみる

| 対象               | 基準 1: 変更頻度 | 基準 2: 変更の種類 | 基準 3: 性質 | 結論          |
| ------------------ | ---------------- | ------------------ | ------------ | ------------- |
| ボタンのレイアウト | 安定             | 壊れは意図外       | 構造         | ✅ VRT 向き   |
| ボタンのラベル     | 頻繁             | 文言変更は意図的   | データ       | ❌ VRT 不向き |
| アイコン位置       | 安定             | 崩れは意図外       | 構造         | ✅ VRT 向き   |

### VRT した方が良いもの

- **variant**: `primary`/`secondary`/`danger` のうち 1 つ（variant による違いは色だけなのでどれか 1 つで十分）
- **アイコンの有無**: アイコン付き/なしを各 1 つずつ（構造が異なる）
- **合計**: 1×2 = 2 パターン

これで、ボタンのレイアウトが崩れていないか、アイコンの位置がずれていないかを確認できます。variant による違いは色くらいなので、いきなり全パターンを VRT の対象にする意味は薄いと思います。

特にボタンの色って結構意識しないと変更できないので、それよりかは padding 調整したりしたときにアイコンとラベルのラインがズレるとかのほうが起こりがちなので、そういうケースに気付けるようにしたいです。

### VRT から除外しても良いもの

- **全バリエーションの網羅**: 同じ構造なら代表例だけで十分
- **ラベルテキストの変更検知**: 文言変更は意図的なので、VRT で検出する必要なし

## 例 2: テーブルコンポーネント（複雑な例）

次に、もう少し複雑なテーブルコンポーネントを見ていきましょう。

![テーブルのキャプチャ](https://storage.googleapis.com/zenn-user-upload/115f2756fe9e-20251128.png)
_テーブル_

:::details 実装コード

```tsx:Table.tsx
type Status = "pending" | "completed" | "error";

type TableRow = {
  id: string;
  name: string;
  status: Status;
  description: string;
};

type TableProps = {
  data: TableRow[];
};

function StatusBadge({ status }: { status: Status }) {
  const statusConfig = {
    pending: {
      label: "保留中",
      color: "bg-gray-100 text-gray-800",
      icon: null,
    },
    completed: {
      label: "完了",
      color: "bg-green-100 text-green-800",
      icon: <CheckIcon className="w-4 h-4" />,
    },
    error: {
      label: "エラー",
      color: "bg-red-100 text-red-800",
      icon: <XIcon className="w-4 h-4" />,
    },
  };

  const { label, color, icon } = statusConfig[status];

  return (
    <span
      className={`w-[100px] px-2 py-1 rounded text-sm font-medium flex items-center gap-1 ${color}`}
    >
      {icon}
      {label}
    </span>
  );
}

export const Table = ({ data }: TableProps) => {
  return (
    <table className="max-w-[800px] divide-y divide-gray-200 border border-gray-200">
      <thead className="bg-gray-50">
        <tr>
          <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase">
            名前
          </th>
          <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase">
            ステータス
          </th>
          <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase">
            説明
          </th>
        </tr>
      </thead>
      <tbody className="bg-white divide-y divide-gray-200">
        {data.map((row) => (
          <tr key={row.id}>
            <td className="px-6 py-4 whitespace-nowrap text-sm font-medium text-gray-900">
              {row.name}
            </td>
            <td className="px-6 py-4 whitespace-nowrap">
              <StatusBadge status={row.status} />
            </td>
            <td className="px-6 py-4 text-sm text-gray-500">
              {row.description}
            </td>
          </tr>
        ))}
      </tbody>
    </table>
  );
};
```

:::

このテーブルの特徴としては

- ステータス列にはそれぞれの状態を表すラベルがある
- ラベルにはアイコン付き/なしのパターンがある
- 説明列はテキストが多い場合に改行される

各カラム毎に複数の表示パターンがあるというのはテーブルのあるあるだと思うのですが、この場合 VRT ではどんなケースを見れば良いのでしょうか 🤔

### 3 つの基準で判断してみる

| 対象                    | 基準 1: 変更頻度                                 | 基準 2: 変更の種類 | 基準 3: 性質 | 結論          |
| ----------------------- | ------------------------------------------------ | ------------------ | ------------ | ------------- |
| テーブルのレイアウト    | 安定                                             | 壊れは意図外       | 構造         | ✅ VRT 向き   |
| ステータス全種類        | 未知数                                           | 追加は意図的       | データ       | ❌ VRT 不向き |
| アイコン付き/なしの構造 | 安定                                             | 崩れは意図外       | 構造         | ✅ VRT 向き   |
| 長文/短文の高さ         | 安定（テキスト自体が持つスタイルは変わりにくい） | 崩れは意図外       | 構造         | ✅ VRT 向き   |

### VRT した方が良いもの

**構造が異なる代表例のみ**を VRT の対象にします：

- **アイコン付きステータス**: `完了`または`エラー`のどちらか 1 つ
- **アイコンなしステータス**: `保留`
- **長文/短文パターン**: 説明文が長い場合と短い場合

これで、テーブルのレイアウト構造が崩れていないか、アイコンの配置が正しいか、長文によるセルの高さの変化に対してレイアウト崩れがないかを確認できます。

### VRT から除外しても良いもの

- **全 3 種類のステータス網羅**: 構造が同じなら代表例だけで十分
- **ステータスの色違いだけの差分**: 色の微調整は意図的な変更
- **データ内容の変化**: API レスポンスが変わっても、構造が同じなら問題なし

### 代表ケースの選び方

ステータスの代表ケースを選ぶときは、**見た目の「構造」が異なるものを選ぶ**のがポイントです。

- 色だけが違うものは 1 つで代表
- アイコンの有無など、構造が変わるものを優先

# ロジックテストとの棲み分け

ここまで読んで、「じゃあステータスの種類が正しく切り替わること自体は、どこで確認すればいいんだろう？」と思われた方もいるかもしれません。

その確認方法はいくつか考えられますが、ひとつのやり方として、**React Testing Library などのテストライブラリでコンポーネント単位のロジックをテストする**方法があります。

## ロジックと見た目の責務分離

- **ロジックテスト**: ステータスの切り替えが期待通りか（全パターンを扱いやすい）
- **VRT**: ステータス表示のレイアウトが崩れないか（代表例だけ押さえる）

例えば、RTL では以下のようなテストが書けます：

```tsx:StatusCell.test.tsx
import { render, screen } from '@testing-library/react';
import { StatusBadge } from './Table';

test('ステータスが"completed"の場合、"完了"と表示される', () => {
  render(<StatusBadge status="completed" />);
  expect(screen.getByText('完了')).toBeInTheDocument();
});

test('ステータスが"error"の場合、"エラー"と表示される', () => {
  render(<StatusBadge status="error" />);
  expect(screen.getByText('エラー')).toBeInTheDocument();
});
```

このように、ロジック部分はテストライブラリで細かく確認しつつ、見た目の崩れは VRT で代表的なパターンだけ押さえる、という方針でテストを作成していくのが良いアプローチかなと思います。

## なぜこの分離が重要か

この分離によって：

- **テストが壊れにくい**: 文言変更で VRT が落ちない
- **保守性が高い**: 新しいステータス追加でも VRT は影響を受けない
- **変更に強い**: ロジック変更とデザイン変更を独立して扱える
- **VRT がノイズにならない**: 本当に見た目が壊れたときだけ VRT が落ちる

# 判断基準のまとめ

最後に、これまで話してきた VRT した方が良いもの・除外しても良いものをまとめたいと思います。

## VRT した方が良いもの

- レイアウトが複雑
- 折り返し or ellipsis が発生する
- 長文の影響が出る可能性がある
- 高さが変わる可能性がある
- UI の利用頻度が高い
- 構造が安定している

## VRT から除外しても良いもの

- 文言が頻繁に変わる
- 新規ページで UI が固まっていない
- データ依存部分（API レスポンス）
- 色だけが違うバリエーション
- デザインリニューアル等の意図的なデザイン変更中のもの

このリストと 3 つの基準を組み合わせて判断すると、VRT の対象を良い感じに絞り込めるかなと思います。

# まとめ

以上、VRT で確認すること・しないことについてまとめてみました。

VRT は正しく使えば最高の味方ですが、過剰に使うとテスト更新地獄に陥ります。今回紹介した「**3 つの基準**」（変更頻度・変更の種類・性質）を使って判断すれば、あなたのプロジェクトでも適切な VRT 範囲を設定できると思います。

大切なのは、VRT を「見た目が壊れていないか」をチェックするツールとして使うことです。ロジックは RTL 等のテストライブラリで、見た目は VRT で、という責務分離を意識すると、テストの保守性が格段に上がりますよ！

それでは、最後まで読んでいただきありがとうございました！👋

# 参考文献

https://playwright.dev/docs/test-snapshots

https://jestjs.io/ja/docs/snapshot-testing

https://testing-library.com/docs/react-testing-library/intro/
