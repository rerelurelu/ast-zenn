---
title: '個人的に考えるVRTで確認すること・しないこと'
emoji: '🔍'
type: 'idea'
topics: ['vrt', 'test', 'frontend']
published: false
---

こんにちは 👋

最近、UI のデグレが多くて VRT を導入したんですが、「これって VRT でテストすべき？それとも別のテストで見るべき？」と迷うことが多かったので、今回はその判断基準について整理したいと思います！

VRT を導入すると必ず「どこまで VRT でテストすべきか」という問題に直面します。全部 VRT でカバーしようとすると、文言変更やステータス追加のたびにテスト更新地獄に陥ってしまいます。

この記事では、VRT の責務の境界線を明確にして、実務で使える判断基準を提示したいと思います。

# VRT の本質: 「見た目のロック」であって「仕様テスト」ではない

まず、VRT が何を検出するのかを理解することが大切です。

VRT が検出するのは**ピクセルレベルの差分**です。画面のスクリーンショットを比較して、「見た目が変わっていないか」をチェックします。

これは言い換えると：

```
VRTは「画面が壊れていないか」を見る
  ↓
「画面の機能が正しいか」は別のテスト（RTL、E2E）の責務
```

という役割分担になります。

スナップショットテストと混同されがちですが、スナップショットテストは DOM 構造（HTML の文字列）を比較するのに対し、VRT は実際にレンダリングされた画面（ピクセル）を比較します。つまり、VRT は CSS、フォント、画像、ブラウザの描画結果まで含めた「見た目」全体を検証するものです。

:::message
全パターンを網羅的に VRT でカバーしようとすると、テスト更新地獄に陥ります。VRT では構造が異なる代表例だけを確認すれば、意図しないレイアウト崩れは十分に検出できます。
:::

# VRT で何を見るべきかの判断軸

それでは、具体的にどうやって「VRT で見るべきもの」と「VRT で見るべきでないもの」を判断すればよいのでしょうか。

わたくしは**3 つの軸**で判断するのが良いと考えています。

## 軸 1: 変更頻度

**VRT 向き**: 安定した構造（レイアウト、余白、配置）
**VRT 不向き**: 頻繁に変わるもの（コピー文言、色の微調整、カラム追加）

レイアウトの構造は一度決まったら頻繁には変わりません。一方、ボタンのラベルやエラーメッセージなどの文言は、リリース前に何度も変更されることがあります。

頻繁に変わるものを VRT で検証すると、変更のたびにスクリーンショットを更新する必要があり、メンテナンスコストが高くなります。

## 軸 2: 変更の意図性

**VRT 向き**: 意図しない破壊を検出（CSS 削除ミス、マージン崩れ）
**VRT 不向き**: 意図的な変更（デザインリニューアル、文言修正）

VRT の真の価値は「意図しない変更」を検出することにあります。

例えば、共通の CSS を削除したときに影響範囲が広すぎて気づけなかった、とか、マージンの指定を間違えてレイアウトが崩れた、といった「うっかりミス」を防ぐのが VRT の役割です。

逆に、デザインリニューアルのように「意図的に見た目を変える」場合は、VRT が落ちるのは当然なので、そもそも VRT で検証する意味がありません。

## 軸 3: テスト対象の性質

**VRT 向き**: コンポーネントの構造（折り返し、高さ、配置）
**VRT 不向き**: データ依存（API レスポンス、動的コンテンツ）

コンポーネントの構造的な部分（例: テキストが長すぎて折り返されたときの高さ、アイコンとテキストの配置）は、VRT で検証するのに適しています。

一方、API から取得したデータの内容（例: ユーザー名、日時、ステータスの種類）は、データが変わるたびに VRT が落ちるため不適切です。

## 3 つの軸の使い方

この 3 つの軸を使って判断する際は、**すべての軸で VRT 向きと判断できる場合のみ、VRT の対象にする**のが良いと思います。

以下の表でまとめてみました：

| 判断軸   | VRT 向き             | VRT 不向き               |
| -------- | -------------------- | ------------------------ |
| 変更頻度 | 安定した構造         | 頻繁に変わる文言やデータ |
| 意図性   | 意図しない破壊を検出 | 意図的なデザイン変更     |
| 性質     | コンポーネントの構造 | データ依存の内容         |

# 具体例で理解する

## VRT で観点とすべきもの

具体例に入る前に、1 点だけ補足しておきたいと思います。

VRT のスクリーンショットには、テキスト・色・アイコン・レイアウトなど、画面に表示されるすべての要素が写り込みます。つまり、テキストや色の変更があれば、VRT の差分検出には必ず引っかかります。

ただし、ここで重要なのは**「何を主な観点として VRT を用意するか」**ということです。

たとえば、テーブルコンポーネントの VRT を用意する場合:

- **主な観点**: レイアウト崩れ、アイコンの配置、行の高さなどの**構造的な部分**
- **副次的に写り込むもの**: テキストの内容、色、ステータスの種類などの**データ的な部分**

つまり、「テキストは VRT で見ない」というのは「スクリーンショットにテキストを写さない」という意味ではなく、「テキストの変更を検出するために VRT を用意するわけではない」という意味です。

この違いを念頭に置いて、具体例を見ていきましょう。

---

それでは、実際のコンポーネントを例に、3 つの軸を使った判断を見ていきましょう。

## 例 1: ボタンコンポーネント（シンプルな例）

まずはシンプルなボタンコンポーネントから見ていきます。

```tsx:Button.tsx
import { ReactNode } from 'react';

type ButtonVariant = 'primary' | 'secondary' | 'danger';

interface ButtonProps {
  variant: ButtonVariant;
  children: ReactNode;
  icon?: ReactNode;
}

export function Button({ variant, children, icon }: ButtonProps) {
  const baseStyle = 'px-4 py-2 rounded font-medium flex items-center gap-2';

  const variantStyles = {
    primary: 'bg-blue-600 text-white hover:bg-blue-700',
    secondary: 'bg-gray-200 text-gray-900 hover:bg-gray-300',
    danger: 'bg-red-600 text-white hover:bg-red-700',
  };

  return (
    <button className={`${baseStyle} ${variantStyles[variant]}`}>
      {icon && <span className="w-5 h-5">{icon}</span>}
      {children}
    </button>
  );
}
```

このボタンコンポーネントには、`primary`/`secondary`/`danger`の 3 つのバリエーションがあります。また、アイコン付き/なしのパターンもあります。

### 3 つの軸で判断してみる

| 対象               | 軸 1: 変更頻度 | 軸 2: 意図性     | 軸 3: 性質 | 結論         |
| ------------------ | -------------- | ---------------- | ---------- | ------------ |
| ボタンのレイアウト | 安定           | 壊れは意図外     | 構造       | ✓ VRT 向き   |
| ボタンのラベル     | 頻繁           | 文言変更は意図的 | データ     | ✗ VRT 不向き |
| アイコン位置       | 安定           | 崩れは意図外     | 構造       | ✓ VRT 向き   |

### VRT すべきケース

- **各バリエーションの代表例**: `primary`/`secondary`/`danger`を各 1 つずつ
- **アイコンの有無**: アイコン付き/なしを各 1 つずつ
- **合計**: 3×2 = 6 パターン程度

これで、ボタンのレイアウトが崩れていないか、アイコンの位置がずれていないかを確認できます。

### VRT すべきでないケース

- **全バリエーションの網羅**: 同じ構造なら代表例だけで十分
- **ラベルテキストの変更検知**: 文言変更は意図的なので、VRT で検出する必要なし

## 例 2: テーブルコンポーネント（複雑な例）

次に、もう少し複雑なテーブルコンポーネントを見ていきましょう。

このテーブルには、ステータス列が 5 種類あり、それぞれ振る舞いが異なります。

```tsx:Table.tsx
import { CheckIcon, XMarkIcon } from '@heroicons/react/24/outline';

type Status = 'pending' | 'processing' | 'completed' | 'error' | 'cancelled';

interface TableRow {
  id: string;
  name: string;
  status: Status;
  description: string;
}

interface TableProps {
  data: TableRow[];
}

function StatusBadge({ status }: { status: Status }) {
  const statusConfig = {
    pending: {
      label: '保留中',
      color: 'bg-gray-100 text-gray-800',
      icon: null
    },
    processing: {
      label: '処理中',
      color: 'bg-blue-100 text-blue-800',
      icon: null
    },
    completed: {
      label: '完了',
      color: 'bg-green-100 text-green-800',
      icon: <CheckIcon className="w-4 h-4" />
    },
    error: {
      label: 'エラー',
      color: 'bg-red-100 text-red-800',
      icon: <XMarkIcon className="w-4 h-4" />
    },
    cancelled: {
      label: 'キャンセル',
      color: 'bg-gray-100 text-gray-800',
      icon: null
    },
  };

  const { label, color, icon } = statusConfig[status];

  return (
    <span className={`px-2 py-1 rounded text-sm font-medium flex items-center gap-1 ${color}`}>
      {icon}
      {label}
    </span>
  );
}

export function Table({ data }: TableProps) {
  return (
    <table className="min-w-full divide-y divide-gray-200">
      <thead className="bg-gray-50">
        <tr>
          <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase">
            名前
          </th>
          <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase">
            ステータス
          </th>
          <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase">
            説明
          </th>
        </tr>
      </thead>
      <tbody className="bg-white divide-y divide-gray-200">
        {data.map((row) => (
          <tr key={row.id}>
            <td className="px-6 py-4 whitespace-nowrap text-sm font-medium text-gray-900">
              {row.name}
            </td>
            <td className="px-6 py-4 whitespace-nowrap">
              <StatusBadge status={row.status} />
            </td>
            <td className="px-6 py-4 text-sm text-gray-500">
              {row.description}
            </td>
          </tr>
        ))}
      </tbody>
    </table>
  );
}
```

### 問題提起

このテーブルには 5 種類のステータスがあり、それぞれ異なる振る舞いをします：

- `completed`と`error`はアイコン付き
- `pending`、`processing`、`cancelled`はアイコンなし
- それぞれ色も違う

「全部のパターンが違うから、5 種類すべてを VRT しなきゃ！」と思いたくなりますが、本当にそうでしょうか？

### 3 つの軸で判断してみる

| 対象                    | 軸 1: 変更頻度     | 軸 2: 意図性 | 軸 3: 性質 | 結論         |
| ----------------------- | ------------------ | ------------ | ---------- | ------------ |
| テーブルのレイアウト    | 安定               | 壊れは意図外 | 構造       | ✓ VRT 向き   |
| ステータス全種類        | 頻繁（追加される） | 追加は意図的 | データ     | ✗ VRT 不向き |
| アイコン付き/なしの構造 | 安定               | 崩れは意図外 | 構造       | ✓ VRT 向き   |
| 長文/短文の高さ         | 安定               | 崩れは意図外 | 構造       | ✓ VRT 向き   |

### VRT すべきケース

**構造が異なる代表例のみ**を VRT の対象にします：

- **アイコン付きステータス**: `completed`または`error`のどちらか 1 つ
- **アイコンなしステータス**: `pending`、`processing`、`cancelled`のどれか 1 つ
- **長文/短文パターン**: 説明文が長い場合と短い場合
- **ヘッダー + 数行のみ**: 全行をスクリーンショットに含める必要はなし

これで、テーブルのレイアウト構造が崩れていないか、アイコンの配置が正しいか、長文によるセルの高さの変化に問題がないかを確認できます。

### VRT すべきでないケース

- **全 5 種類のステータス網羅**: 構造が同じなら代表例だけで十分
- **ステータスの色違いだけの差分**: 色の微調整は意図的な変更
- **データ内容の変化**: API レスポンスが変わっても、構造が同じなら問題なし

### 代表ケースの選び方

ステータスの代表ケースを選ぶときは、**見た目の「構造」が異なるものを選ぶ**のがポイントです。

- 色だけが違うものは 1 つで代表
- テキストの長さが極端に違うものを含める（最大/最小）
- アイコンの有無など、構造が変わるものを優先

# ロジックテストとの棲み分け

ここまで読んで、「じゃあステータスの種類が正しく切り替わること自体は、どこで確認すればいいんだろう？」と思われた方もいるかもしれません。

その確認方法はいくつか考えられますが、ひとつのやり方として、**React Testing Library（RTL など）でコンポーネント単位のロジックをテストする**方法があります。

## ロジックと見た目の責務分離

- **ロジックテスト**: ステータスの切り替えが期待通りか（全パターンを扱いやすい）
- **VRT**: ステータス表示のレイアウトが崩れないか（代表例だけ押さえる）

例えば、RTL では以下のようなテストが書けます：

```tsx:StatusCell.test.tsx
import { render, screen } from '@testing-library/react';
import { StatusBadge } from './Table';

test('ステータスが"completed"の場合、"完了"と表示される', () => {
  render(<StatusBadge status="completed" />);
  expect(screen.getByText('完了')).toBeInTheDocument();
});

test('ステータスが"error"の場合、"エラー"と表示される', () => {
  render(<StatusBadge status="error" />);
  expect(screen.getByText('エラー')).toBeInTheDocument();
});
```

このように、ロジック部分はテストライブラリで細かく確認しつつ、見た目の崩れは VRT で代表的なパターンだけ押さえる、という方針でテストを作成していくのが良いアプローチかなと思います。

## なぜこの分離が重要か

この分離によって：

- **テストが壊れにくい**: 文言変更で VRT が落ちない
- **保守性が高い**: 新しいステータス追加でも VRT は影響を受けない
- **変更に強い**: ロジック変更とデザイン変更を独立して扱える
- **VRT がノイズにならない**: 本当に見た目が壊れたときだけ VRT が落ちる

# 実践的なチェックリスト

最後に、実務で使える判断基準をチェックリスト形式でまとめます。

## VRT に入れるべきもの

- ✓ レイアウトが複雑
- ✓ 折り返し or ellipsis が発生する
- ✓ 長文の影響が出る可能性がある
- ✓ 高さが変わる可能性がある
- ✓ UI の利用頻度が高い
- ✓ 構造が安定している

## VRT から除外すべきもの

- ✗ 文言が頻繁に変わる
- ✗ 新規ページで UI が固まっていない
- ✗ データ依存部分（API レスポンス）
- ✗ カラムが変わりやすいテーブル
- ✗ 色だけが違うバリエーション
- ✗ 意図的なデザイン変更中

このチェックリストと 3 つの軸を組み合わせて判断すると、VRT の対象を適切に絞り込めるかなと思います。

# まとめ: VRT は「万能」ではなく「専門家」

以上、VRT で確認すること・しないことについてまとめてみました。

VRT は正しく使えば最高の味方ですが、過剰に使うとテスト更新地獄に陥ります。今回紹介した「**3 つの軸**」（変更頻度・意図性・性質）を使って判断すれば、あなたのプロジェクトでも適切な VRT 範囲を設定できると思います。

大切なのは、VRT を「UI テストの万能ツール」として扱うのではなく、「意図しない見た目の破壊を検出する専門家」として使うことです。ロジックは RTL で、見た目は VRT で、という責務分離を意識すると、テストの保守性が格段に上がりますよ！

それでは、最後まで読んでいただきありがとうございました！👋

# 参考文献

https://playwright.dev/docs/test-snapshots

https://jestjs.io/ja/docs/snapshot-testing

https://testing-library.com/docs/react-testing-library/intro/
